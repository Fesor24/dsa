//Array operations
int[] myArr = {1,4,5,6,7,8};

1. Display
for(int i = 0; i < myArr.Length; i++)
{
    WriteLine($"Value at index {i} is {myArr[i]}");
}

2. Add/Append
Adding the element to the end of the array
Where the length is less then the size
myArr[Length++] = value;
Time complexity is O(1)

3. Insert at a specified index
Where Length is the number of items and array has Size greater than Length
int index = 2;
int value = 10;

for(int i = myArr.Length - 1; i > index; i--)
{
    myArr[i + 1] = myArr[i];
}   

myArr[index] = value;
// Worst case - O(n)
// Best case - O(1)

4. Delete operation
Removing an element from a specified index
When we remove an item from an index, we do not leave it vacant(null)
Otherwise, for each element we would have to check if an item is there or not
So instead of keeping it blank, we would shift the other elements
example, delete item an index 3
myArr = {3,4,5,6,7}

for(int i = index; i < myArr.Length - 1; i++)
    myArr[i] = myArr[i + 1];
    
// Worst case - O(n)
// Best case - O(1)

5. Search
For performing search, items in the array should be unique

i. Linear
myArr = {1,4,6,8,9,11,3,7,20}
key = 9;

for(i = 0; i < myArr.Length; i++)
{
    if(myArr[i] == key)
        return i;
}
return -1;

// Best case - O(1)
// Worst case - O(n)
// Average case - O(n)

Improvement of linear search
1. Transposition: By swapping the element
e.g myArr = {4,5,6,7,20}, if 20 is searched the first time, after looking for it, we swap with the 
previous element so it now becomes {4,5,6,20,7} if 20 is searched again, it becomes {4,5,20,6,7}
Basically, transposing...this reduces the linear search time by 1 for subsequent search for the same item

2. Move to front: when we find the element, we bring it to the beginning of the array, by swapping with the first element
If we do this, the next time the element is searched if almost immediately, this will be done in constant time

ii. Binary
Items in the array must be sorted
myArr = {1,4,6,7,10,13,18};
key = 13;

int left = 0;
int right = myArr.Length;
int mid;

while (left <= right)
{
    mid = (left + right) / 2;
    
    if(myArr[mid] == key)
        return mid;
        
    else if(key < myArr[mid])
    {
        right = mid - 1;
    }
        
    else
    {
        left = mid + 1;
    } 
}
return -1;

6. Get operation
Getting an element at a particular index

7. Set operation
Replace a value at a particular index

8. Get maximum/minimum
In an unsorted listed, we would have to check the entire list
myArr = {4,3,10,19,2}

int max = myArr[0];
for(int i = 1; i < myArr.Length; i++)
{
    if(max < myArr[i])
        max = myArr[i];
}

9. Get Sum/Average
Sum with recursion
myArr = {3,4,5,7};

int Sum(int[]arr, int n)
{
    // This part prevents it from running infinitely
    if(n < 0)
        return 0;
        
    return Sum(arr, n - 1) + arr[n];
}

Sum(myArr, myArr.Length - 1);